<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Happy heart Runner</title>
  <style>
    :root{
      /* Modern, vibrant theme */
      --sky1:#7bd2ff; /* top */
      --sky2:#f2fbff; /* bottom */
      --accent:#7c5cff; /* primary */
      --accent-2:#00d4ff; /* secondary */
      --grass:#37e17c;
      --dirt:#b97a56;
      --ui:#0e1222;
      --white:#fff;
      --shadow:rgba(20,24,40,.25);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; overflow:hidden;
      background:
        radial-gradient(1200px 700px at 15% 10%, rgba(255,255,255,.9), transparent 60%),
        radial-gradient(1000px 600px at 85% 0%, rgba(124,92,255,.18), transparent 60%),
        linear-gradient(180deg,var(--sky1),var(--sky2));
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      color:var(--ui);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    canvas#game{position:fixed; inset:0; width:100%; height:100%; display:block}

    /* HUD */
    .hud{position:fixed; inset:0; pointer-events:none}
    .top-bar{
      position:absolute; left:0; right:0; top:0; display:flex; align-items:center; justify-content:space-between;
      padding: clamp(8px, 2.5vmin, 20px);
    }
    .score, .best{
      pointer-events:none; font-weight:900; letter-spacing:.3px;
      font-size: clamp(18px, 3.4vmin, 30px);
      color:#0e1222;
      text-shadow: 0 2px 0 rgba(255,255,255,.85), 0 10px 30px rgba(124,92,255,.25);
    }
    .controls{ display:flex; gap:8px; align-items:center; }
    .btn{
      pointer-events:auto; cursor:pointer; border:1px solid rgba(14,18,34,.08); outline:0;
      background:linear-gradient(180deg,#fff, #f4f6ff);
      color:#111; font-weight:700;
      padding:.55em .9em; border-radius:999px; box-shadow: 0 10px 30px var(--shadow);
      font-size: clamp(14px, 2.2vmin, 17px);
      transition: transform .08s ease, box-shadow .2s ease, filter .2s ease;
    }
    .btn:active{ transform: translateY(1px) scale(.98) }
    .btn[hidden]{display:none}

    /* Overlays */
    .overlay{ position:fixed; inset:0; display:grid; place-items:center; pointer-events:none }
    .card{
      pointer-events:auto; background:rgba(255,255,255,.82);
      backdrop-filter: blur(10px) saturate(1.2);
      border:1px solid rgba(14,18,34,.08);
      border-radius:24px; box-shadow:0 20px 70px rgba(20,24,40,.3);
      padding: clamp(18px, 5vmin, 44px);
      text-align:center; max-width:min(640px, 92vw); color:#0f1324;
    }
    .title{ font-size: clamp(28px, 6vmin, 52px); margin:0 0 .2em; font-weight:900; letter-spacing:.3px; }
    .subtitle{ margin:.2em 0 .8em; opacity:.8; font-size: clamp(14px, 2.4vmin, 18px); }

    .seg{ display:inline-flex; gap:0; border-radius:999px; overflow:hidden; border:1px solid rgba(14,18,34,.08); box-shadow:0 8px 24px rgba(20,24,40,.16); }
    .seg button{
      pointer-events:auto; cursor:pointer; border:0; padding:.5em 1em; font-weight:800;
      background:#fff; color:#0f1324; letter-spacing:.2px;
    }
    .seg button.active{ background:linear-gradient(180deg, var(--accent), #5e44ff); color:#fff; }

    .hide{ display:none }

    .tap-hint{ position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      background:rgba(255,255,255,.86); padding:.4em .8em; border-radius:999px; font-weight:700;
      box-shadow:0 8px 24px rgba(0,0,0,.18); font-size: clamp(12px, 2.2vmin, 16px); }
  </style>
</head>
<body>
  <canvas id="game" aria-label="Happy heart Runner game canvas" role="img"></canvas>

  <div class="hud" aria-live="polite">
    <div class="top-bar">
      <div class="score" id="score">0</div>
      <div class="controls">
        <button class="btn" id="muteBtn" title="Toggle sound" aria-pressed="false">ðŸ”Š Sound</button>
        <button class="btn" id="retryTop" title="Restart" hidden>â†» Retry</button>
      </div>
      <div class="best" id="best">BEST: 0</div>
    </div>
  </div>

  <div class="overlay" id="startOverlay">
    <div class="card">
      <h1 class="title">Happy heart Runner</h1>
      <p class="subtitle">Jump over obstacles and survive as long as possible. Choose difficulty. Beat your high score!</p>
      <div style="display:flex; gap:12px; justify-content:center; align-items:center; margin:.6em 0 1em">
        <span style="font-weight:800">Difficulty:</span>
        <div class="seg" role="tablist" aria-label="Difficulty">
          <button id="diffEasy" class="active" role="tab" aria-selected="true">Easy</button>
          <button id="diffNormal" role="tab" aria-selected="false">Normal</button>
        </div>
      </div>
      <p class="subtitle"><b>SPACE</b> / <b>â†‘</b> / click or tap to jump</p>
      <button class="btn" id="startBtn">Start</button>
    </div>
  </div>

  <div class="overlay hide" id="gameOverOverlay">
    <div class="card">
      <h2 class="title" style="font-size: clamp(22px,5vmin,42px)">Game Over ðŸ’¥</h2>
      <p class="subtitle" id="finalScore">Score: 0</p>
      <p class="subtitle" id="finalBest">Best: 0</p>
      <div style="display:flex; gap:.6em; justify-content:center; flex-wrap:wrap; margin-top:.5em">
        <button class="btn" id="retryBtn">â†» Retry</button>
        <button class="btn" id="shareBtn">Share</button>
      </div>
    </div>
  </div>

  <div class="tap-hint" id="tapHint">Tap / Click to JUMP</div>

<script>
(() => {
  // ------ Canvas setup ------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W = 0, H = 0, DPR = Math.max(1, window.devicePixelRatio || 1);
  function resize(){
    DPR = Math.max(1, window.devicePixelRatio || 1);
    W = window.innerWidth; H = window.innerHeight;
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ------ Elements ------
  const startOverlay = document.getElementById('startOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const finalScoreEl = document.getElementById('finalScore');
  const finalBestEl = document.getElementById('finalBest');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const startBtn = document.getElementById('startBtn');
  const retryBtn = document.getElementById('retryBtn');
  const retryTop = document.getElementById('retryTop');
  const shareBtn = document.getElementById('shareBtn');
  const tapHint = document.getElementById('tapHint');
  const muteBtn = document.getElementById('muteBtn');
  const diffEasyBtn = document.getElementById('diffEasy');
  const diffNormalBtn = document.getElementById('diffNormal');

  const STORAGE_KEY = 'happyHeartBest';
  const DIFF_KEY = 'happyHeartDiff';
  let BEST = Number(localStorage.getItem(STORAGE_KEY) || 0);
  bestEl.textContent = `BEST: ${BEST}`;
  let difficulty = localStorage.getItem(DIFF_KEY) || 'easy';

  // reflect saved difficulty
  if(difficulty==='normal'){ diffEasyBtn.classList.remove('active'); diffEasyBtn.setAttribute('aria-selected','false'); diffNormalBtn.classList.add('active'); diffNormalBtn.setAttribute('aria-selected','true'); }

  let state = 'intro'; // intro | playing | gameover

  // ------ Audio ------
  const SFX = (()=>{
    let actx = null, muted = false;
    function ensure(){ if(!actx){ const Ctx = window.AudioContext || window.webkitAudioContext; actx = new Ctx(); }}
    function now(){ return actx ? actx.currentTime : 0; }
    function envGain(duration=0.2, peak=0.8){ const g = actx.createGain(); g.gain.setValueAtTime(0, now()); g.gain.linearRampToValueAtTime(peak, now()+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now()+duration); g.connect(actx.destination); return g; }
    function beep({freq=600, duration=0.2, type='sine', glideTo=null}){ if(muted) return; ensure(); const o=actx.createOscillator(); o.type=type; o.frequency.setValueAtTime(freq, now()); if(glideTo){ o.frequency.exponentialRampToValueAtTime(glideTo, now()+duration*0.9);} const g=envGain(duration,0.6); o.connect(g); o.start(); o.stop(now()+duration);} 
    function noise({duration=0.25, band=800}){ if(muted) return; ensure(); const bufferSize=actx.sampleRate*duration; const buffer=actx.createBuffer(1, bufferSize, actx.sampleRate); const data=buffer.getChannelData(0); for(let i=0;i<bufferSize;i++){ data[i]=(Math.random()*2-1)*Math.exp(-i/band);} const src=actx.createBufferSource(); src.buffer=buffer; const g=envGain(duration,0.9); src.connect(g); src.start(); }
    return { jump(){beep({freq:520,glideTo:980,duration:0.2,type:'triangle'})}, land(){beep({freq:200,glideTo:140,duration:0.12,type:'square'})}, hit(){ noise({duration:0.3,band:320}); beep({freq:110,duration:0.18,type:'sawtooth'}); }, score(){beep({freq:760,glideTo:1300,duration:0.12,type:'triangle'})}, toggleMute(){ muted=!muted; return muted; }, get muted(){ return muted; }, resume(){ if(actx && actx.state==='suspended') actx.resume(); } };
  })();

  // ------ Utilities ------
  const rand = (a,b)=> a + Math.random()*(b-a);
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));

  // ------ Difficulty presets ------
  const PRESETS = {
    easy:   { speed:260, speedRamp:10, speedMax:780, coyote:0.18, jumpBuf:0.2, jumpVy:760, grav:1580, jumpHold:0.52, hitScale:0.58, noColl:1.6, noSpawnDist:1400, obsH:[28,60], obsW:[26,46], gapPad:240, gapMul:0.48 },
    normal: { speed:340, speedRamp:16, speedMax:900, coyote:0.12, jumpBuf:0.14, jumpVy:720, grav:1700, jumpHold:0.45, hitScale:0.68, noColl:1.2, noSpawnDist:900,  obsH:[36,78], obsW:[28,52], gapPad:180, gapMul:0.44 }
  };

  // ------ World state ------
  const GROUND_H = 120;
  let speed, speedMax, distance, spawnTimer, score, milestone, noCollisionFor, noSpawnUntilDist;
  let jumpBuffered = 0;

  // Runner (person)
  const runner = { x: 160, y: 0, vy: 0, r: 26, onGround: true, jumpHeld:false, coyote:0.12, legPhase:0 };

  // Obstacles
  const obstacles = [];

  function applyDifficulty(){
    const p = PRESETS[difficulty];
    speed = p.speed; speedMax = p.speedMax; distance = 0; spawnTimer = 0; score = 0; milestone = 100;
    noCollisionFor = p.noColl; noSpawnUntilDist = p.noSpawnDist; runner.coyote = p.coyote; JUMP_CUTOFF = p.jumpHold; GRAV = p.grav; JUMP_VY = p.jumpVy; HIT_SCALE = p.hitScale; GAP_PAD = p.gapPad; GAP_MUL = p.gapMul; OBH=p.obsH; OBW=p.obsW; SPEED_RAMP = p.speedRamp;
  }

  // Difficulty UI
  diffEasyBtn.addEventListener('click', ()=>{ difficulty='easy'; localStorage.setItem(DIFF_KEY,'easy'); diffEasyBtn.classList.add('active'); diffEasyBtn.setAttribute('aria-selected','true'); diffNormalBtn.classList.remove('active'); diffNormalBtn.setAttribute('aria-selected','false'); });
  diffNormalBtn.addEventListener('click', ()=>{ difficulty='normal'; localStorage.setItem(DIFF_KEY,'normal'); diffNormalBtn.classList.add('active'); diffNormalBtn.setAttribute('aria-selected','true'); diffEasyBtn.classList.remove('active'); diffEasyBtn.setAttribute('aria-selected','false'); });

  // ------ Helpers ------
  function resetGame(){
    obstacles.length = 0; runner.y = 0; runner.vy = 0; runner.onGround = true; runner.legPhase = 0; jumpBuffered = 0;
    applyDifficulty();
    updateHUD();
  }
  function startGame(){ resetGame(); state='playing'; hide(startOverlay); hide(gameOverOverlay); retryTop.hidden = true; tapHint.style.opacity = 0; }
  function endGame(){ state='gameover'; retryTop.hidden = false; SFX.hit(); BEST = Math.max(BEST, Math.floor(score)); localStorage.setItem(STORAGE_KEY, String(BEST)); finalScoreEl.textContent = `Score: ${Math.floor(score)}`; finalBestEl.textContent = `Best: ${BEST}`; bestEl.textContent = `BEST: ${BEST}`; show(gameOverOverlay); }
  function updateHUD(){ scoreEl.textContent = Math.floor(score); }

  // ------ Input ------
  function isJumpKey(code){ return code==='Space' || code==='ArrowUp' || code==='KeyW'; }
  function queueJump(){ const p=PRESETS[difficulty]; if(runner.onGround || runner.coyote>0){ doJump(); } else { jumpBuffered = p.jumpBuf; } }
  function onDown(){ if(state==='intro'){ startGame(); return; } if(state==='gameover'){ startGame(); return; } if(state!=='playing') return; queueJump(); }
  function onUp(){ runner.jumpHeld=false; }
  window.addEventListener('keydown', (e)=>{ if(isJumpKey(e.code)){ e.preventDefault(); onDown(); tryResumeAudio(); } if(e.code==='KeyR'){ e.preventDefault(); if(state!=='playing') startGame(); } });
  window.addEventListener('keyup', (e)=>{ if(isJumpKey(e.code)) onUp(); });
  window.addEventListener('pointerdown', ()=>{ onDown(); tryResumeAudio(); });
  window.addEventListener('pointerup', onUp);
  startBtn.addEventListener('click', ()=>{ startGame(); tryResumeAudio(); });
  retryBtn.addEventListener('click', ()=>{ startGame(); });
  retryTop.addEventListener('click', ()=>{ startGame(); });
  shareBtn.addEventListener('click', async ()=>{ const text = `I scored ${Math.floor(score)} in Happy heart Runner! Can you beat my best of ${BEST}?`; if(navigator.share){ try{ await navigator.share({title:'Happy heart Runner', text, url: location.href}); }catch(_){} } else { navigator.clipboard?.writeText(text); alert('Copied score to clipboard!'); } });
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden) last = performance.now(); });
  muteBtn.addEventListener('click', ()=>{ const muted = SFX.toggleMute(); muteBtn.textContent = muted ? 'ðŸ”ˆ Muted' : 'ðŸ”Š Sound'; muteBtn.setAttribute('aria-pressed', String(muted)); });
  function tryResumeAudio(){ SFX.resume(); }

  // ------ Parallax background ------
  const clouds = Array.from({length: 10}, ()=>({ x: rand(0,W), y: rand(20, H*0.5), s: rand(40, 140), v: rand(6, 26) }));
  const birds  = Array.from({length: 5 }, ()=>({ x: rand(0,W), y: rand(H*0.15, H*0.5), v: rand(60, 120), flap: rand(0, Math.PI*2) }));
  function drawSky(){
    const sunR = Math.min(W,H)*0.08; ctx.save(); ctx.globalAlpha = .9; ctx.fillStyle = '#ffd166'; ctx.beginPath(); ctx.arc(W*0.12, H*0.18, sunR, 0, Math.PI*2); ctx.fill(); ctx.restore();
    clouds.forEach(c=>{ c.x -= (speed * 0.07 + c.v) * dt; if(c.x + c.s*2 < -20){ c.x = W + rand(20, 200); c.y = rand(20, H*0.5); c.s = rand(40, 140);} drawCloud(c.x, c.y, c.s); });
    drawHills(H*0.72, '#a8f3bc', 0.18); drawHills(H*0.78, '#79e89d', 0.28); drawHills(H*0.84, '#4fdc83', 0.42);
  }
  function drawCloud(x,y,s){ ctx.save(); ctx.fillStyle = 'rgba(255,255,255,.95)'; ctx.beginPath(); ctx.arc(x, y, s*0.42, 0, Math.PI*2); ctx.arc(x+s*0.36, y-s*0.18, s*0.32, 0, Math.PI*2); ctx.arc(x+s*0.72, y, s*0.44, 0, Math.PI*2); ctx.closePath(); ctx.fill(); ctx.restore(); }
  function drawHills(baseY, color, factor){ ctx.save(); ctx.fillStyle = color; const step = 260; let off = (distance*factor)%step; ctx.beginPath(); ctx.moveTo(-step+off, baseY); for(let x=-step; x<=W+step; x+=step){ const h = 80 + 40*Math.sin((x+off)/280); ctx.quadraticCurveTo(x+off+step*0.5, baseY-h, x+off+step, baseY);} ctx.lineTo(W, H); ctx.lineTo(0,H); ctx.closePath(); ctx.fill(); ctx.restore(); }
  function drawGround(){ const y = H - GROUND_H; ctx.fillStyle = '#e8c3aa'; ctx.fillRect(0, y+48, W, GROUND_H-48); ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--grass') || '#37e17c'; ctx.fillRect(0, y, W, 60); const tileW = 64; const off = (distance*1.2)%tileW; for(let x=-tileW; x<=W+tileW; x+=tileW){ ctx.fillStyle = x%128===0 ? 'rgba(255,255,255,.22)' : 'rgba(0,0,0,.08)'; ctx.fillRect(Math.floor(x-off), y+40, tileW*0.5, 10);} }

  // ------ Obstacles ------
  let OBH=[28,60], OBW=[26,46], GAP_PAD=220, GAP_MUL=0.46, SPEED_RAMP=12; // overwritten by presets
  function spawnObstacle(){ const w = rand(OBW[0], OBW[1]); const h = rand(OBH[0], OBH[1]); const x = Math.max(W + rand(0, 140), runner.x + 360); obstacles.push({ x, y: H - GROUND_H - h, w, h, face: Math.random()<0.6 }); }
  function updateObstacles(dt){ const spd = speed; spawnTimer -= dt; if(distance < noSpawnUntilDist){ spawnTimer = 0.15; } if(spawnTimer<=0 && distance >= noSpawnUntilDist){ spawnObstacle(); const airtime = 0.6 * PRESETS[difficulty].jumpHold + 0.25; const expectedJumpDist = spd * (0.32 + airtime*0.4); const minGap = clamp(expectedJumpDist + GAP_PAD, 360, 560); const maxGap = minGap + 180; spawnTimer = rand(minGap, maxGap) / spd; } for(let i=obstacles.length-1;i>=0;i--){ const o = obstacles[i]; o.x -= spd*dt; if(o.x + o.w < -40) obstacles.splice(i,1); } }
  function drawObstacles(){ ctx.save(); obstacles.forEach(o=>{ const r = 10; ctx.fillStyle = '#ff9f1c'; roundRect(o.x, o.y, o.w, o.h, r, true); ctx.fillStyle = 'rgba(255,255,255,.2)'; roundRect(o.x, o.y, o.w, 8, {tl:r,tr:r,br:0,bl:0}, true); if(o.face){ ctx.save(); ctx.translate(o.x+o.w*0.5, o.y+o.h*0.35); ctx.fillStyle = '#1f1f1f'; ctx.beginPath(); ctx.arc(-6,0,2.2,0,Math.PI*2); ctx.arc(6,-1,2.2,0,Math.PI*2); ctx.fill(); ctx.strokeStyle = '#1f1f1f'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-8,8); ctx.quadraticCurveTo(0,14, 8,8); ctx.stroke(); ctx.restore(); } ctx.fillStyle = 'rgba(0,0,0,.12)'; ctx.fillRect(o.x+2, o.y+o.h, o.w-4, 4); }); ctx.restore(); }
  function roundRect(x, y, w, h, r, fill){ let tl, tr, br, bl; if(typeof r === 'number'){ tl=tr=br=bl=r; } else{ ({tl=0,tr=0,br=0,bl=0} = r); } ctx.beginPath(); ctx.moveTo(x+tl, y); ctx.lineTo(x+w-tr, y); ctx.quadraticCurveTo(x+w, y, x+w, y+tr); ctx.lineTo(x+w, y+h-br); ctx.quadraticCurveTo(x+w, y+h, x+w-br, y+h); ctx.lineTo(x+bl, y+h); ctx.quadraticCurveTo(x, y+h, x, y+h-bl); ctx.lineTo(x, y+tl); ctx.quadraticCurveTo(x, y, x+tl, y); if(fill) ctx.fill(); else ctx.stroke(); }

  // ------ Runner drawing: person (cartoon) ------
  function drawRunner(){
    const baseY = H - GROUND_H; const x = runner.x; const y = baseY - runner.y;

    // shadow
    const shadowScale = clamp(1 - (runner.y/260), 0.3, 1);
    ctx.save(); ctx.fillStyle = 'rgba(0,0,0,.18)'; ctx.beginPath(); ctx.ellipse(x, baseY-6, 34*shadowScale, 10*shadowScale, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();

    // person
    ctx.save(); ctx.translate(x, y);
    const running = runner.onGround; const phase = runner.legPhase; const swing = running ? Math.sin(phase*10) : 0.2; // arm/leg swing

    // torso
    ctx.fillStyle = '#111827';
    roundPath(-10, -24, 20, 38, 8, true);
    // head
    ctx.fillStyle = '#ffd4b8'; ctx.beginPath(); ctx.arc(0, -38, 10, 0, Math.PI*2); ctx.fill();
    // hair cap
    ctx.fillStyle = '#111827'; ctx.beginPath(); ctx.arc(0, -40, 11, Math.PI*0.95, Math.PI*2.05); ctx.fill();
    // face
    ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(-3.6, -39, 1.3, 0, Math.PI*2); ctx.arc(3.6, -39.5, 1.3, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#111'; ctx.lineWidth = 1.6; ctx.beginPath(); ctx.arc(0, -35, 3.4, 0.1*Math.PI, 0.9*Math.PI); ctx.stroke();

    // arms (opposite swing)
    ctx.strokeStyle = '#111827'; ctx.lineWidth = 4; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(-10, -18); ctx.lineTo(-10 - 10*swing, -18 + 12*Math.abs(swing)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(10, -18); ctx.lineTo(10 + 10*swing, -18 - 12*Math.abs(swing)); ctx.stroke();

    // legs
    ctx.strokeStyle = '#1f2937'; ctx.lineWidth = 5; ctx.beginPath(); ctx.moveTo(-5, 14); ctx.lineTo(-5 - 12*swing, 24); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(5, 14); ctx.lineTo(5 + 12*swing, 24); ctx.stroke();
    // shoes
    ctx.fillStyle = '#7c5cff'; ctx.beginPath(); ctx.ellipse(-5 - 12*swing, 27, 6, 3.6, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse( 5 + 12*swing, 27, 6, 3.6, 0, 0, Math.PI*2); ctx.fill();

    ctx.restore();
  }
  function roundPath(x,y,w,h,r,fill){ let tl=typeof r==='number'?r:r.tl, tr=typeof r==='number'?r:r.tr, br=typeof r==='number'?r:r.br, bl=typeof r==='number'?r:r.bl; ctx.beginPath(); ctx.moveTo(x+tl, y); ctx.lineTo(x+w-tr, y); ctx.quadraticCurveTo(x+w, y, x+w, y+tr); ctx.lineTo(x+w, y+h-br); ctx.quadraticCurveTo(x+w, y+h, x+w-br, y+h); ctx.lineTo(x+bl, y+h); ctx.quadraticCurveTo(x, y+h, x, y+h-bl); ctx.lineTo(x, y+tl); ctx.quadraticCurveTo(x, y, x+tl, y); if(fill) ctx.fill(); else ctx.stroke(); }

  // ------ Particles ------
  const puffs = [];
  function spawnPuff(x, y){ for(let i=0;i<12;i++){ puffs.push({ x, y, vx: rand(-140,140), vy: rand(-60,-200), life: rand(.5,.9), r: rand(2,5) }); } }
  function updatePuffs(dt){ for(let i=puffs.length-1;i>=0;i--){ const p = puffs[i]; p.vy += 900*dt; p.x += p.vx*dt; p.y += p.vy*dt; p.life -= dt; if(p.life<=0) puffs.splice(i,1); } }
  function drawPuffs(){ ctx.save(); ctx.fillStyle = 'rgba(255,255,255,.8)'; puffs.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill(); }); ctx.restore(); }

  // ------ Physics & collision (tuned easier) ------
  let GRAV = 1600, JUMP_CUTOFF = 0.5, JUMP_VY = 740, HIT_SCALE = 0.64;
  function doJump(){ runner.vy = JUMP_VY; runner.onGround = false; runner.coyote = 0; runner.jumpHeld = true; SFX.jump(); spawnPuff(runner.x, H-GROUND_H-2); jumpBuffered = 0; }
  function updateRunner(dt){
    // buffered jump
    if(jumpBuffered>0){ jumpBuffered -= dt; if((runner.onGround || runner.coyote>0) && state==='playing'){ doJump(); }}

    if(!runner.onGround){ if(runner.jumpHeld && jumpTime < JUMP_CUTOFF){ runner.vy += 900*dt; jumpTime += dt; } runner.vy -= GRAV * dt; runner.y += runner.vy * dt; if(runner.y <= 0){ runner.y = 0; runner.vy = 0; runner.onGround = true; SFX.land(); } }
    else { runner.legPhase += (speed/360) * dt; runner.coyote = PRESETS[difficulty].coyote; jumpTime = 0; }

    if(!runner.onGround){ runner.coyote -= dt; }

    if(noCollisionFor>0) noCollisionFor -= dt; const grace = noCollisionFor>0;
    const rx = runner.x; const ry = H - GROUND_H - runner.y; const rr = runner.r*HIT_SCALE;
    if(!grace){
      for(const o of obstacles){
        // forgiving top: if runner is clearly above top, ignore
        const aboveTop = (ry+rr) < (o.y + 6);
        if(aboveTop) continue;
        if(rx+rr > o.x && rx-rr < o.x+o.w && ry+rr > o.y && ry-rr < o.y+o.h){ endGame(); break; }
      }
    }
  }

  // ------ Birds ------
  function drawBirds(){ birds.forEach(b=>{ b.x -= (speed*0.25 + b.v) * dt; b.flap += dt*10; if(b.x<-40){ b.x = W + rand(60,200); b.y = rand(H*0.12, H*0.45);} drawBird(b.x, b.y, Math.sin(b.flap)>0); }); }
  function drawBird(x,y,wingUp){ ctx.save(); ctx.translate(x,y); ctx.fillStyle = '#5b7cff'; ctx.beginPath(); ctx.ellipse(0,0,14,9,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(5,-2,2.2,0,Math.PI*2); ctx.fill(); ctx.fillStyle = '#ffb703'; ctx.beginPath(); ctx.moveTo(11,1); ctx.lineTo(16,0); ctx.lineTo(11,-1); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#4a67d8'; ctx.beginPath(); if(wingUp){ ctx.moveTo(-2,0); ctx.quadraticCurveTo(-14,-10, -2,-6); } else { ctx.moveTo(-2,0); ctx.quadraticCurveTo(-14, 10, -2, 6); } ctx.lineTo(-2,0); ctx.fill(); ctx.restore(); }

  // ------ Main loop ------
  let last = performance.now(); let dt = 0;
  function frame(t){ dt = (t - last)/1000; if(dt>0.05) dt=0.05; last = t; ctx.clearRect(0,0,W,H); drawSky(); drawBirds(); if(state==='playing'){ distance += speed*dt; score = distance/10; if(score>=milestone){ milestone+=100; SFX.score(); } speed = clamp(speed + SPEED_RAMP*dt, 0, speedMax); updateObstacles(dt); updateRunner(dt); updatePuffs(dt); updateHUD(); } drawGround(); drawObstacles(); drawRunner(); drawPuffs(); requestAnimationFrame(frame); }
  requestAnimationFrame(frame);

  // ------ UI helpers ------
  function show(el){ el.classList.remove('hide'); }
  function hide(el){ el.classList.add('hide'); }

  // UX hint
  setTimeout(()=>{ tapHint.style.opacity = 1; }, 400);

})();
</script>
</body>
</html>